<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Creating a Trait - Tick</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="../index.html">Tick</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../index.html">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="index.html">Creating a Trait</a>
</li>

                        
                            
<li >
    <a href="../requires/index.html">Template constraints</a>
</li>

                        
                            
<li >
    <a href="../check/index.html">Checking a Trait</a>
</li>

                        
                            
<li >
    <a href="../tag/index.html">Tag dispatching</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../requirements/index.html">Requirements</a>
</li>

                        
                            
<li >
    <a href="../acknowledgments/index.html">Acknowledgments</a>
</li>

                        
                            
<li >
    <a href="../design/index.html">Design Notes</a>
</li>

                        
                            
<li >
    <a href="../zlang/index.html">ZLang</a>
</li>

                        
                            
<li >
    <a href="../license/index.html">License</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../index.html">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../requires/index.html">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/pfultz2/Tick">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#building-traits">Building traits</a></li>
        
            <li><a href="#refinements">Refinements</a></li>
        
    
        <li class="main "><a href="#query-operations">Query operations</a></li>
        
            <li><a href="#type-matching">Type matching</a></li>
        
            <li><a href="#returns">returns</a></li>
        
            <li><a href="#has_type">has_type</a></li>
        
            <li><a href="#has_template">has_template</a></li>
        
            <li><a href="#trait-evaluation">Trait evaluation</a></li>
        
            <li><a href="#helper-functions">Helper functions</a></li>
        
    
        <li class="main "><a href="#build-traits-without-macros">Build traits without macros</a></li>
        
            <li><a href="#refinements_1">Refinements</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="building-traits">Building traits</h1>
<p>This macro will build a boolean type trait for you. Each trait has a <code>require</code> member function of the form:</p>
<pre><code class="cpp">TICK_TRAIT(my_trait)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        ...
    &gt;;
};
</code></pre>

<p>This will essentially build a class that inherits from <code>integral_constant</code>, so the above is equivalent to this:</p>
<pre><code class="cpp">template&lt;class... Ts&gt;
struct my_trait
: integral_constant&lt;bool, (...)&gt;
{};
</code></pre>

<p>The parameters to the trait are based on the parameters passed to the <code>require</code> function. </p>
<p>The trait will be either true or false if the expressions given are valid. Each expression in <code>valid</code> needs a <code>decltype</code> around it. If one of the expressions is not valid, the the trait will return false. For example,</p>
<pre><code class="cpp">TICK_TRAIT(my_trait)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(x++)
    &gt;;
};
</code></pre>

<p>The trait above will check that <code>x++</code> is a valid expression.</p>
<h2 id="refinements">Refinements</h2>
<p>Refinements can be expressed after the name. Each refinement is a <a href="http://www.boost.org/doc/libs/1_55_0/libs/mpl/doc/refmanual/placeholder-expression.html">placeholder expression</a>, where each placeholder(ie <code>_1</code>, <code>_2</code>, etc) are replaced by their corresponding type passed into the trait. In the case of traits that accept a single parameter the unnamed placeholder(<code>_</code>) can be used, for example:</p>
<pre><code class="cpp">TICK_TRAIT(is_incrementable, std::is_default_constructible&lt;_&gt;)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(x++),
        decltype(++x)
    &gt;;
};
</code></pre>

<p>This trait will be true when <code>x++</code> and <code>++x</code> are valid expressions and <code>x</code> is default constructible.</p>
<p>When a trait has multiple parameters, its best to use named placeholders. For example:</p>
<pre><code class="cpp">TICK_TRAIT(is_equality_comparable, 
    std::is_default_constructible&lt;_1&gt;, 
    std::is_default_constructible&lt;_2&gt;)
{
    template&lt;class T, class U&gt;
    auto require(T&amp;&amp; x, U&amp;&amp; y) -&gt; valid&lt;
        decltype(x == y),
        decltype(x != y)
    &gt;;
};
</code></pre>

<p>This trait will be true when <code>x == y</code> and <code>x != y</code> are valid expressions and both <code>x</code> and <code>y</code> are default constructible.</p>
<p>In addition <code>quote</code> can be used to pass all the args from the trait to the refinement:</p>
<pre><code class="cpp">TICK_TRAIT(is_comparable, 
    quote&lt;is_equality_comparable&gt;)
{
    template&lt;class T, class U&gt;
    auto require(T&amp;&amp; x, U&amp;&amp; y) -&gt; valid&lt;
        decltype(x &lt; y),
        decltype(x &lt;= y),
        decltype(x &gt;= y),
        decltype(x &gt; y)
    &gt;;
};
</code></pre>

<h1 id="query-operations">Query operations</h1>
<p>These can be used to query more information about the types then just valid expressions.</p>
<h2 id="type-matching">Type matching</h2>
<p>When a type is matched, it can either be convertible to the type given, or the evaluated placeholder expression must be true. Placeholder expressions can be given so the type can be matched against other traits.</p>
<h2 id="returns">returns</h2>
<p>The <code>returns</code> query can check if the result of the expressions matches the type. For example,</p>
<pre><code class="cpp">TICK_TRAIT(is_incrementable)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(returns&lt;int&gt;(x++))
    &gt;;
};
</code></pre>

<p>This trait will be true if the expressions <code>x++</code> is valid and is convertible to <code>int</code>.</p>
<p>Here's an example using placeholder expressions as well:</p>
<pre><code class="cpp">TICK_TRAIT(is_incrementable)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(returns&lt;std::is_integral&lt;_&gt;&gt;(x++))
    &gt;;
};
</code></pre>

<p>This trait will be true if the expressions <code>x++</code> is valid and returns a type that <code>is_integral</code>.</p>
<p>Note: The <code>TICK_RETURNS</code> macro can be used instead to improve compatability with older compilers(such as gcc 4.6):</p>
<pre><code class="cpp">TICK_TRAIT(is_incrementable)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        TICK_RETURNS(x++, int)
    &gt;;
};
</code></pre>

<p>Also, <code>returns&lt;void&gt;</code> is prohibited.</p>
<pre><code class="cpp">TICK_TRAIT(is_incrementable)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(returns&lt;void&gt;(x++)) // Compiler error
    &gt;;
};
</code></pre>

<p>Instead, use either <code>decltype</code> directly without <code>returns</code>, or if there is a possibility of <code>void</code> from a computed type, use <code>TICK_RETURNS</code> or <code>has_type</code> instead.</p>
<h2 id="has_type">has_type</h2>
<p>The <code>has_type</code> query can check if a type exist and if the type matches. For example:</p>
<pre><code class="cpp">TICK_TRAIT(has_nested_type)
{
    template&lt;class T&gt;
    auto require(const T&amp; x) -&gt; valid&lt;
        has_type&lt;typename T::type&gt;
    &gt;;
};
</code></pre>

<p>This trait will be true if <code>T</code> has a nested type called <code>type</code>.</p>
<p>Now <code>has_type</code> used as above is not quite as useful since the above example, can also be simply written without <code>has_type</code> like this:</p>
<pre><code class="cpp">TICK_TRAIT(has_nested_type)
{
    template&lt;class T&gt;
    auto require(const T&amp; x) -&gt; valid&lt;
        typename T::type
    &gt;;
};
</code></pre>

<p>So, an optional second parameter can be provided to check if the type matches. Here's an example:</p>
<pre><code class="cpp">TICK_TRAIT(has_nested_int_type)
{
    template&lt;class T&gt;
    auto require(const T&amp; x) -&gt; valid&lt;
        has_type&lt;typename T::type, std::is_integral&lt;_&gt;&gt;
    &gt;;
};
</code></pre>

<p>This trait will be true if <code>T</code> has a nested type called <code>type</code> which is an integral type.</p>
<h2 id="has_template">has_template</h2>
<p>The <code>has_template</code> query can check if a template exist. For example:</p>
<pre><code class="cpp">TICK_TRAIT(has_nested_result)
{
    template&lt;class T&gt;
    auto require(const T&amp; x) -&gt; valid&lt;
        has_template&lt;T::template result&gt;
    &gt;;
};
</code></pre>

<p>This trait will be true if <code>T</code> has a nested template called <code>result</code>.</p>
<h2 id="trait-evaluation">Trait evaluation</h2>
<p>The <code>is_true</code> and <code>is_false</code> queries can check if a trait is true or false. Using refinements is the preferred way of checking for additional traits, but this can be useful if the evaluation of some trait can't be used lazily with placeholder expressions. So the <code>is_true</code> and <code>is_false</code> can be used instead, for example:</p>
<pre><code class="cpp">TICK_TRAIT(is_2d_array)
{
    template&lt;class T&gt;
    auto require(const T&amp; x) -&gt; valid&lt;
        is_true&lt;std::is_same&lt;std::rank&lt;T&gt;::type, std::integral_constant&lt;std::size_t, 2&gt;&gt; &gt;
    &gt;;
};
</code></pre>

<h2 id="helper-functions">Helper functions</h2>
<p>The library also provides <code>as_const</code> and <code>as_mutable</code> functions to ensure lvalues are either <code>const</code> or <code>mutable</code> respectively:</p>
<pre><code class="cpp">TICK_TRAIT(is_copy_assignable)
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(x = as_const(x))
    &gt;;
};
</code></pre>

<h1 id="build-traits-without-macros">Build traits without macros</h1>
<p>The traits can be built without using the <code>TICK_TRAIT</code> macros. However, it may introduce problems with portability. So if only one platform is needed to be supported, then here's how to build them. First, build a class for the <code>require</code> functions and inherit from <code>tick::ops</code> to bring in all the query operations:</p>
<pre><code class="cpp">struct is_incrementable_r : tick::ops
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(x++),
        decltype(++x)
    &gt;;
};
</code></pre>

<p>Next, turn it into a trait using <code>tick::models</code>:</p>
<pre><code class="cpp">template&lt;class... Ts&gt;
struct is_incrementable
: tick::models&lt;is_incrementable_r, Ts...&gt;
{};
</code></pre>

<h2 id="refinements_1">Refinements</h2>
<p>Refinements can be used by using the <code>tick::refines</code> class:</p>
<pre><code class="cpp">struct is_incrementable_r 
: tick::ops, tick::refines&lt;std::is_default_constructible&lt;tick::_&gt;&gt;
{
    template&lt;class T&gt;
    auto require(T&amp;&amp; x) -&gt; valid&lt;
        decltype(x++),
        decltype(++x)
    &gt;;
};
</code></pre>

<p>Notice, the placeholders have to be fully qualified here.</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
