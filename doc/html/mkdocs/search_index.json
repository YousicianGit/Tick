{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Tick\n\n\nTrait introspection and concept creator for C++11\n\n\nGetting Started\n\n\nTick provides a mechanism for easily defining and using traits in C++11. For example, if we defined a generic \nincrement\n function, like this:\n\n\ntemplate\nclass T\n\nvoid increment(T\n x)\n{\n    x++;\n}\n\n\n\n\nIf we pass something that does not have the \n++\n operator to \nincrement\n, we will get an error inside of the \nincrement\n function. This can make it unclear whether the error is due to a mistake by the user of the function or by the implementor of the function. Instead we want to check the type requirements of the function. \n\n\nUsing Tick we can create an \nis_incrementable\n trait, like this:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\n\nAnd then we can use a simple requires clause in our function to check the type requirements:\n\n\ntemplate\nclass T, TICK_REQUIRES(is_incrementable\nT\n())\n\nvoid increment(T\n x)\n{\n    x++;\n}\n\n\n\n\nSo, now, if we pass something that is not incrementable to \nincrement\n:\n\n\nstruct foo {};\n\nfoo f;\nincrement(f);\n\n\n\n\nThen we get an error like this in clang:\n\n\ndemo.cpp:25:2: error: no matching function for call to 'increment'\n        increment(f);\n        ^~~~~~~~~\ndemo.cpp:14:19: note: candidate template ignored: disabled by 'enable_if' [with T = foo]\ntemplate\nclass T, TICK_REQUIRES(is_incrementable\nT\n())\n\n                  ^\n\n\n\nThis gives an error at the call to \nincrement\n rather than inside the function, and then pointes to the type requirements of the function. This gives enough information for most commons cases, however, sometimes we may want more information. In that case the \nTICK_TRAIT_CHECK\n can be used. For example, say we had the \nis_incrementable\n trait defined like this:\n\n\nTICK_TRAIT(is_incrementable, std::is_integral\n_\n)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\n\nThen if we use \nTICK_TRAIT_CHECK\n, we can see why \nint*\n is not incrementable:\n\n\nTICK_TRAIT_CHECK(is_incrementable\nint*\n);\n\n\n\n\nWhich will produce this error:\n\n\n../tick/trait_check.h:95:38: error: implicit instantiation of undefined template 'tick::TRAIT_CHECK_FAILURE\nstd::is_integral\nint *\n, is_incrementable\nint *\n \n'\n\n\n\nWhich shows the traits that failed including any refinements. So we can see that it failed because \nstd::is_integral\nint *\n is not true.", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#tick", 
            "text": "Trait introspection and concept creator for C++11", 
            "title": "Tick"
        }, 
        {
            "location": "/index.html#getting-started", 
            "text": "Tick provides a mechanism for easily defining and using traits in C++11. For example, if we defined a generic  increment  function, like this:  template class T \nvoid increment(T  x)\n{\n    x++;\n}  If we pass something that does not have the  ++  operator to  increment , we will get an error inside of the  increment  function. This can make it unclear whether the error is due to a mistake by the user of the function or by the implementor of the function. Instead we want to check the type requirements of the function.   Using Tick we can create an  is_incrementable  trait, like this:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  And then we can use a simple requires clause in our function to check the type requirements:  template class T, TICK_REQUIRES(is_incrementable T ()) \nvoid increment(T  x)\n{\n    x++;\n}  So, now, if we pass something that is not incrementable to  increment :  struct foo {};\n\nfoo f;\nincrement(f);  Then we get an error like this in clang:  demo.cpp:25:2: error: no matching function for call to 'increment'\n        increment(f);\n        ^~~~~~~~~\ndemo.cpp:14:19: note: candidate template ignored: disabled by 'enable_if' [with T = foo]\ntemplate class T, TICK_REQUIRES(is_incrementable T ()) \n                  ^  This gives an error at the call to  increment  rather than inside the function, and then pointes to the type requirements of the function. This gives enough information for most commons cases, however, sometimes we may want more information. In that case the  TICK_TRAIT_CHECK  can be used. For example, say we had the  is_incrementable  trait defined like this:  TICK_TRAIT(is_incrementable, std::is_integral _ )\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  Then if we use  TICK_TRAIT_CHECK , we can see why  int*  is not incrementable:  TICK_TRAIT_CHECK(is_incrementable int* );  Which will produce this error:  ../tick/trait_check.h:95:38: error: implicit instantiation of undefined template 'tick::TRAIT_CHECK_FAILURE std::is_integral int * , is_incrementable int *   '  Which shows the traits that failed including any refinements. So we can see that it failed because  std::is_integral int *  is not true.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/builder/index.html", 
            "text": "Building traits\n\n\nThis macro will build a boolean type trait for you. Each trait has a \nrequire\n member function of the form:\n\n\nTICK_TRAIT(my_trait)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        ...\n    \n;\n};\n\n\n\n\nThis will essentially build a class that inherits from \nintegral_constant\n, so the above is equivalent to this:\n\n\ntemplate\nclass... Ts\n\nstruct my_trait\n: integral_constant\nbool, (...)\n\n{};\n\n\n\n\nThe parameters to the trait are based on the parameters passed to the \nrequire\n function. \n\n\nThe trait will be either true or false if the expressions given are valid. Each expression in \nvalid\n needs a \ndecltype\n around it. If one of the expressions is not valid, the the trait will return false. For example,\n\n\nTICK_TRAIT(my_trait)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++)\n    \n;\n};\n\n\n\n\nThe trait above will check that \nx++\n is a valid expression.\n\n\nRefinements\n\n\nRefinements can be expressed after the name. Each refinement is a \nplaceholder expression\n, where each placeholder(ie \n_1\n, \n_2\n, etc) are replaced by their corresponding type passed into the trait. In the case of traits that accept a single parameter the unnamed placeholder(\n_\n) can be used, for example:\n\n\nTICK_TRAIT(is_incrementable, std::is_default_constructible\n_\n)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\n\nThis trait will be true when \nx++\n and \n++x\n are valid expressions and \nx\n is default constructible.\n\n\nWhen a trait has multiple parameters, its best to use named placeholders. For example:\n\n\nTICK_TRAIT(is_equality_comparable, \n    std::is_default_constructible\n_1\n, \n    std::is_default_constructible\n_2\n)\n{\n    template\nclass T, class U\n\n    auto require(T\n x, U\n y) -\n valid\n\n        decltype(x == y),\n        decltype(x != y)\n    \n;\n};\n\n\n\n\nThis trait will be true when \nx == y\n and \nx != y\n are valid expressions and both \nx\n and \ny\n are default constructible.\n\n\nIn addition \nquote\n can be used to pass all the args from the trait to the refinement:\n\n\nTICK_TRAIT(is_comparable, \n    quote\nis_equality_comparable\n)\n{\n    template\nclass T, class U\n\n    auto require(T\n x, U\n y) -\n valid\n\n        decltype(x \n y),\n        decltype(x \n= y),\n        decltype(x \n= y),\n        decltype(x \n y)\n    \n;\n};\n\n\n\n\nQuery operations\n\n\nThese can be used to query more information about the types then just valid expressions.\n\n\nType matching\n\n\nWhen a type is matched, it can either be convertible to the type given, or the evaluated placeholder expression must be true. Placeholder expressions can be given so the type can be matched against other traits.\n\n\nreturns\n\n\nThe \nreturns\n query can check if the result of the expressions matches the type. For example,\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(returns\nint\n(x++))\n    \n;\n};\n\n\n\n\nThis trait will be true if the expressions \nx++\n is valid and is convertible to \nint\n.\n\n\nHere's an example using placeholder expressions as well:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(returns\nstd::is_integral\n_\n(x++))\n    \n;\n};\n\n\n\n\nThis trait will be true if the expressions \nx++\n is valid and returns a type that \nis_integral\n.\n\n\nNote: The \nTICK_RETURNS\n macro can be used instead to improve compatability with older compilers(such as gcc 4.6):\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        TICK_RETURNS(x++, int)\n    \n;\n};\n\n\n\n\nAlso, \nreturns\nvoid\n is prohibited.\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(returns\nvoid\n(x++)) // Compiler error\n    \n;\n};\n\n\n\n\nInstead, use either \ndecltype\n directly without \nreturns\n, or if there is a possibility of \nvoid\n from a computed type, use \nTICK_RETURNS\n or \nhas_type\n instead.\n\n\nhas_type\n\n\nThe \nhas_type\n query can check if a type exist and if the type matches. For example:\n\n\nTICK_TRAIT(has_nested_type)\n{\n    template\nclass T\n\n    auto require(const T\n x) -\n valid\n\n        has_type\ntypename T::type\n\n    \n;\n};\n\n\n\n\nThis trait will be true if \nT\n has a nested type called \ntype\n.\n\n\nNow \nhas_type\n used as above is not quite as useful since the above example, can also be simply written without \nhas_type\n like this:\n\n\nTICK_TRAIT(has_nested_type)\n{\n    template\nclass T\n\n    auto require(const T\n x) -\n valid\n\n        typename T::type\n    \n;\n};\n\n\n\n\nSo, an optional second parameter can be provided to check if the type matches. Here's an example:\n\n\nTICK_TRAIT(has_nested_int_type)\n{\n    template\nclass T\n\n    auto require(const T\n x) -\n valid\n\n        has_type\ntypename T::type, std::is_integral\n_\n\n    \n;\n};\n\n\n\n\nThis trait will be true if \nT\n has a nested type called \ntype\n which is an integral type.\n\n\nhas_template\n\n\nThe \nhas_template\n query can check if a template exist. For example:\n\n\nTICK_TRAIT(has_nested_result)\n{\n    template\nclass T\n\n    auto require(const T\n x) -\n valid\n\n        has_template\nT::template result\n\n    \n;\n};\n\n\n\n\nThis trait will be true if \nT\n has a nested template called \nresult\n.\n\n\nTrait evaluation\n\n\nThe \nis_true\n and \nis_false\n queries can check if a trait is true or false. Using refinements is the preferred way of checking for additional traits, but this can be useful if the evaluation of some trait can't be used lazily with placeholder expressions. So the \nis_true\n and \nis_false\n can be used instead, for example:\n\n\nTICK_TRAIT(is_2d_array)\n{\n    template\nclass T\n\n    auto require(const T\n x) -\n valid\n\n        is_true\nstd::is_same\nstd::rank\nT\n::type, std::integral_constant\nstd::size_t, 2\n \n\n    \n;\n};\n\n\n\n\nHelper functions\n\n\nThe library also provides \nas_const\n and \nas_mutable\n functions to ensure lvalues are either \nconst\n or \nmutable\n respectively:\n\n\nTICK_TRAIT(is_copy_assignable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x = as_const(x))\n    \n;\n};\n\n\n\n\nBuild traits without macros\n\n\nThe traits can be built without using the \nTICK_TRAIT\n macros. However, it may introduce problems with portability. So if only one platform is needed to be supported, then here's how to build them. First, build a class for the \nrequire\n functions and inherit from \ntick::ops\n to bring in all the query operations:\n\n\nstruct is_incrementable_r : tick::ops\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\n\nNext, turn it into a trait using \ntick::models\n:\n\n\ntemplate\nclass... Ts\n\nstruct is_incrementable\n: tick::models\nis_incrementable_r, Ts...\n\n{};\n\n\n\n\nRefinements\n\n\nRefinements can be used by using the \ntick::refines\n class:\n\n\nstruct is_incrementable_r \n: tick::ops, tick::refines\nstd::is_default_constructible\ntick::_\n\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\n\nNotice, the placeholders have to be fully qualified here.", 
            "title": "Creating a Trait"
        }, 
        {
            "location": "/builder/index.html#building-traits", 
            "text": "This macro will build a boolean type trait for you. Each trait has a  require  member function of the form:  TICK_TRAIT(my_trait)\n{\n    template class T \n    auto require(T  x) -  valid \n        ...\n     ;\n};  This will essentially build a class that inherits from  integral_constant , so the above is equivalent to this:  template class... Ts \nstruct my_trait\n: integral_constant bool, (...) \n{};  The parameters to the trait are based on the parameters passed to the  require  function.   The trait will be either true or false if the expressions given are valid. Each expression in  valid  needs a  decltype  around it. If one of the expressions is not valid, the the trait will return false. For example,  TICK_TRAIT(my_trait)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++)\n     ;\n};  The trait above will check that  x++  is a valid expression.", 
            "title": "Building traits"
        }, 
        {
            "location": "/builder/index.html#refinements", 
            "text": "Refinements can be expressed after the name. Each refinement is a  placeholder expression , where each placeholder(ie  _1 ,  _2 , etc) are replaced by their corresponding type passed into the trait. In the case of traits that accept a single parameter the unnamed placeholder( _ ) can be used, for example:  TICK_TRAIT(is_incrementable, std::is_default_constructible _ )\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  This trait will be true when  x++  and  ++x  are valid expressions and  x  is default constructible.  When a trait has multiple parameters, its best to use named placeholders. For example:  TICK_TRAIT(is_equality_comparable, \n    std::is_default_constructible _1 , \n    std::is_default_constructible _2 )\n{\n    template class T, class U \n    auto require(T  x, U  y) -  valid \n        decltype(x == y),\n        decltype(x != y)\n     ;\n};  This trait will be true when  x == y  and  x != y  are valid expressions and both  x  and  y  are default constructible.  In addition  quote  can be used to pass all the args from the trait to the refinement:  TICK_TRAIT(is_comparable, \n    quote is_equality_comparable )\n{\n    template class T, class U \n    auto require(T  x, U  y) -  valid \n        decltype(x   y),\n        decltype(x  = y),\n        decltype(x  = y),\n        decltype(x   y)\n     ;\n};", 
            "title": "Refinements"
        }, 
        {
            "location": "/builder/index.html#query-operations", 
            "text": "These can be used to query more information about the types then just valid expressions.", 
            "title": "Query operations"
        }, 
        {
            "location": "/builder/index.html#type-matching", 
            "text": "When a type is matched, it can either be convertible to the type given, or the evaluated placeholder expression must be true. Placeholder expressions can be given so the type can be matched against other traits.", 
            "title": "Type matching"
        }, 
        {
            "location": "/builder/index.html#returns", 
            "text": "The  returns  query can check if the result of the expressions matches the type. For example,  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(returns int (x++))\n     ;\n};  This trait will be true if the expressions  x++  is valid and is convertible to  int .  Here's an example using placeholder expressions as well:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(returns std::is_integral _ (x++))\n     ;\n};  This trait will be true if the expressions  x++  is valid and returns a type that  is_integral .  Note: The  TICK_RETURNS  macro can be used instead to improve compatability with older compilers(such as gcc 4.6):  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        TICK_RETURNS(x++, int)\n     ;\n};  Also,  returns void  is prohibited.  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(returns void (x++)) // Compiler error\n     ;\n};  Instead, use either  decltype  directly without  returns , or if there is a possibility of  void  from a computed type, use  TICK_RETURNS  or  has_type  instead.", 
            "title": "returns"
        }, 
        {
            "location": "/builder/index.html#has_type", 
            "text": "The  has_type  query can check if a type exist and if the type matches. For example:  TICK_TRAIT(has_nested_type)\n{\n    template class T \n    auto require(const T  x) -  valid \n        has_type typename T::type \n     ;\n};  This trait will be true if  T  has a nested type called  type .  Now  has_type  used as above is not quite as useful since the above example, can also be simply written without  has_type  like this:  TICK_TRAIT(has_nested_type)\n{\n    template class T \n    auto require(const T  x) -  valid \n        typename T::type\n     ;\n};  So, an optional second parameter can be provided to check if the type matches. Here's an example:  TICK_TRAIT(has_nested_int_type)\n{\n    template class T \n    auto require(const T  x) -  valid \n        has_type typename T::type, std::is_integral _ \n     ;\n};  This trait will be true if  T  has a nested type called  type  which is an integral type.", 
            "title": "has_type"
        }, 
        {
            "location": "/builder/index.html#has_template", 
            "text": "The  has_template  query can check if a template exist. For example:  TICK_TRAIT(has_nested_result)\n{\n    template class T \n    auto require(const T  x) -  valid \n        has_template T::template result \n     ;\n};  This trait will be true if  T  has a nested template called  result .", 
            "title": "has_template"
        }, 
        {
            "location": "/builder/index.html#trait-evaluation", 
            "text": "The  is_true  and  is_false  queries can check if a trait is true or false. Using refinements is the preferred way of checking for additional traits, but this can be useful if the evaluation of some trait can't be used lazily with placeholder expressions. So the  is_true  and  is_false  can be used instead, for example:  TICK_TRAIT(is_2d_array)\n{\n    template class T \n    auto require(const T  x) -  valid \n        is_true std::is_same std::rank T ::type, std::integral_constant std::size_t, 2   \n     ;\n};", 
            "title": "Trait evaluation"
        }, 
        {
            "location": "/builder/index.html#helper-functions", 
            "text": "The library also provides  as_const  and  as_mutable  functions to ensure lvalues are either  const  or  mutable  respectively:  TICK_TRAIT(is_copy_assignable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x = as_const(x))\n     ;\n};", 
            "title": "Helper functions"
        }, 
        {
            "location": "/builder/index.html#build-traits-without-macros", 
            "text": "The traits can be built without using the  TICK_TRAIT  macros. However, it may introduce problems with portability. So if only one platform is needed to be supported, then here's how to build them. First, build a class for the  require  functions and inherit from  tick::ops  to bring in all the query operations:  struct is_incrementable_r : tick::ops\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  Next, turn it into a trait using  tick::models :  template class... Ts \nstruct is_incrementable\n: tick::models is_incrementable_r, Ts... \n{};", 
            "title": "Build traits without macros"
        }, 
        {
            "location": "/builder/index.html#refinements_1", 
            "text": "Refinements can be used by using the  tick::refines  class:  struct is_incrementable_r \n: tick::ops, tick::refines std::is_default_constructible tick::_ \n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  Notice, the placeholders have to be fully qualified here.", 
            "title": "Refinements"
        }, 
        {
            "location": "/requires/index.html", 
            "text": "Template constraints\n\n\nThree macros are provided to help improve the readability of template constraints.\n\n\nTICK_REQUIRES\n\n\nThe \nTICK_REQUIRES\n can be used on template parameters. For example,\n\n\ntemplate\nclass T, TICK_REQUIRES(is_incrementable\nT\n())\n\nvoid increment(T\n x)\n{\n    x++;\n}\n\n\n\n\nTICK_CLASS_REQUIRES\n\n\nThe \nTICK_CLASS_REQUIRES\n can be used when template specialization is done on classes. For example,\n\n\ntemplate\nclass T, class=void\n\nstruct foo\n{\n    ...\n};\n\ntemplate\nclass T\n\nstruct foo\nT, TICK_CLASS_REQUIRES(is_incrementable\nT\n() and not std::is_integral\nT\n())\n\n{\n    ...\n};\n\ntemplate\nclass T\n\nstruct foo\nT, TICK_CLASS_REQUIRES(std::is_integral\nT\n())\n\n{\n    ...\n};\n\n\n\n\nTICK_MEMBER_REQUIRES\n\n\nThe \nTICK_MEMBER_REQUIRES\n can be used for member function inside of classes, that are not templated. For example,\n\n\ntemplate\nclass T\n\nstruct foo\n{\n    T x;\n\n    TICK_MEMBER_REQUIRES(is_incrementable\nT\n())\n    void up()\n    {\n        x++;\n    }\n};\n\n\n\n\nTICK_PARAM_REQUIRES\n\n\nThe \nTICK_PARAM_REQUIRES\n can be used in the paramater of the function. This is useful for lambdas:\n\n\nauto increment = [](auto\n x, TICK_PARAM_REQUIRES(is_incrementable\ndecltype(x)\n()))\n{\n    x++;\n};\n\n\n\n\nAlso, the \ntrait\n function is provided which can be used to deduce the type of the parameters:\n\n\nauto increment = [](auto\n x, TICK_PARAM_REQUIRES(trait\nis_incrementable\n(x)))\n{\n    x++;\n};\n\n\n\n\nNote: The \ntrait\n function always deduces the type without references. So \ntrait\nstd::is_lvalue_reference\n(x)\n will always be false.\n\n\nTICK_FUNCTION_REQUIRES\n\n\nThe \nTICK_FUNCTION_REQUIRES\n can be used on functions. This requires placing parenthesis around the return type:\n\n\ntemplate\nclass T\n\nTICK_FUNCTION_REQUIRES(is_incrementable\nT\n())\n(void) increment(T\n x)\n{\n    x++;\n}\n\n\n\n\nNote: The \nTICK_REQUIRES\n should be preferred.", 
            "title": "Template constraints"
        }, 
        {
            "location": "/requires/index.html#template-constraints", 
            "text": "Three macros are provided to help improve the readability of template constraints.", 
            "title": "Template constraints"
        }, 
        {
            "location": "/requires/index.html#tick_requires", 
            "text": "The  TICK_REQUIRES  can be used on template parameters. For example,  template class T, TICK_REQUIRES(is_incrementable T ()) \nvoid increment(T  x)\n{\n    x++;\n}", 
            "title": "TICK_REQUIRES"
        }, 
        {
            "location": "/requires/index.html#tick_class_requires", 
            "text": "The  TICK_CLASS_REQUIRES  can be used when template specialization is done on classes. For example,  template class T, class=void \nstruct foo\n{\n    ...\n};\n\ntemplate class T \nstruct foo T, TICK_CLASS_REQUIRES(is_incrementable T () and not std::is_integral T ()) \n{\n    ...\n};\n\ntemplate class T \nstruct foo T, TICK_CLASS_REQUIRES(std::is_integral T ()) \n{\n    ...\n};", 
            "title": "TICK_CLASS_REQUIRES"
        }, 
        {
            "location": "/requires/index.html#tick_member_requires", 
            "text": "The  TICK_MEMBER_REQUIRES  can be used for member function inside of classes, that are not templated. For example,  template class T \nstruct foo\n{\n    T x;\n\n    TICK_MEMBER_REQUIRES(is_incrementable T ())\n    void up()\n    {\n        x++;\n    }\n};", 
            "title": "TICK_MEMBER_REQUIRES"
        }, 
        {
            "location": "/requires/index.html#tick_param_requires", 
            "text": "The  TICK_PARAM_REQUIRES  can be used in the paramater of the function. This is useful for lambdas:  auto increment = [](auto  x, TICK_PARAM_REQUIRES(is_incrementable decltype(x) ()))\n{\n    x++;\n};  Also, the  trait  function is provided which can be used to deduce the type of the parameters:  auto increment = [](auto  x, TICK_PARAM_REQUIRES(trait is_incrementable (x)))\n{\n    x++;\n};  Note: The  trait  function always deduces the type without references. So  trait std::is_lvalue_reference (x)  will always be false.", 
            "title": "TICK_PARAM_REQUIRES"
        }, 
        {
            "location": "/requires/index.html#tick_function_requires", 
            "text": "The  TICK_FUNCTION_REQUIRES  can be used on functions. This requires placing parenthesis around the return type:  template class T \nTICK_FUNCTION_REQUIRES(is_incrementable T ())\n(void) increment(T  x)\n{\n    x++;\n}  Note: The  TICK_REQUIRES  should be preferred.", 
            "title": "TICK_FUNCTION_REQUIRES"
        }, 
        {
            "location": "/check/index.html", 
            "text": "Trait checking\n\n\nThe \nTICK_TRAIT_CHECK\n macro will statically assert the list of traits that are true but it will show what traits failed including base traits. This can be useful to show more informative messages about why a trait is false.", 
            "title": "Checking a Trait"
        }, 
        {
            "location": "/check/index.html#trait-checking", 
            "text": "The  TICK_TRAIT_CHECK  macro will statically assert the list of traits that are true but it will show what traits failed including base traits. This can be useful to show more informative messages about why a trait is false.", 
            "title": "Trait checking"
        }, 
        {
            "location": "/tag/index.html", 
            "text": "Tag dispatching\n\n\nTag dispatching allows for functions to be ordered by the refinements defined in the trait. For example, if we try to implement an \nadvance\n function like \nstd::advance\n. First, we can define the traits for the different traversals:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\nTICK_TRAIT(is_decrementable, is_incrementable\n_\n)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x--),\n        decltype(--x)\n    \n;\n};\n\nTICK_TRAIT(is_advanceable, is_decrementable\n_\n)\n{\n    template\nclass T, class Number\n\n    auto require(T\n x, Number n) -\n valid\n\n        decltype(x += n)\n    \n;\n};\n\n\n\n\nThen we can try to use template constraints for the different overloads:\n\n\ntemplate\nclass Iterator, TICK_REQUIRES(is_advanceable\nIterator\n())\n\nvoid advance(Iterator\n it, int n)\n{\n    it += n;\n}\n\ntemplate\nclass Iterator, TICK_REQUIRES(is_decrementable\nIterator\n())\n\nvoid advance(Iterator\n it, int n)\n{\n    if (n \n 0) while (n--) ++it;\n    else \n    {\n        n *= -1;\n        while (n--) --it;\n    }\n}\n\ntemplate\nclass Iterator, TICK_REQUIRES(is_incrementable\nIterator\n())\n\nvoid advance(Iterator\n it, int n)\n{\n    while (n--) ++it;\n}\n\n\n\n\nHowever, this leads to ambiguities when we try to use it with iterators to vectors. That is because those iterators are valid for all three overloads. So, tag dispatching allows us to pick the overload that is the most refined. First, we need to call \nmost_refined\n which will retrieve the tags for each each trait. So then \nadvance\n could be implemented like this:\n\n\ntemplate\nclass Iterator\n\nvoid advance_impl(Iterator\n it, int n, tick::tag\nis_advanceable\n)\n{\n    it += n;\n}\n\ntemplate\nclass Iterator\n\nvoid advance_impl(Iterator\n it, int n, tick::tag\nis_decrementable\n)\n{\n    if (n \n 0) while (n--) ++it;\n    else \n    {\n        n *= -1;\n        while (n--) --it;\n    }\n}\n\ntemplate\nclass Iterator\n\nvoid advance_impl(Iterator\n it, int n, tick::tag\nis_incrementable\n)\n{\n    while (n--) ++it;\n}\n\ntemplate\nclass Iterator\n\nvoid advance(Iterator\n it, int n)\n{\n    advance_impl(it, n, tick::most_refined\nis_advanceable\nIterator\n());\n}\n\n\n\n\nSpecialization\n\n\nTag dispatching will still work with specialization. Say, for instance, someone implemented an iterator called \nfoo_iterator\n that when the user called \n+=\n it would crash at runtime. So we would like to specialize \nis_advanceable\n to make it false, so the \n+=\n won't be called:\n\n\ntemplate\n\nstruct is_advanceable\nfoo_iterator\n\n: std::false_type\n{};\n\n\n\n\nSo this will exclude the \nis_advanceable\n overload, but the \nis_decrementable\n and \nis_incrementable\n will still be called.", 
            "title": "Tag dispatching"
        }, 
        {
            "location": "/tag/index.html#tag-dispatching", 
            "text": "Tag dispatching allows for functions to be ordered by the refinements defined in the trait. For example, if we try to implement an  advance  function like  std::advance . First, we can define the traits for the different traversals:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};\n\nTICK_TRAIT(is_decrementable, is_incrementable _ )\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x--),\n        decltype(--x)\n     ;\n};\n\nTICK_TRAIT(is_advanceable, is_decrementable _ )\n{\n    template class T, class Number \n    auto require(T  x, Number n) -  valid \n        decltype(x += n)\n     ;\n};  Then we can try to use template constraints for the different overloads:  template class Iterator, TICK_REQUIRES(is_advanceable Iterator ()) \nvoid advance(Iterator  it, int n)\n{\n    it += n;\n}\n\ntemplate class Iterator, TICK_REQUIRES(is_decrementable Iterator ()) \nvoid advance(Iterator  it, int n)\n{\n    if (n   0) while (n--) ++it;\n    else \n    {\n        n *= -1;\n        while (n--) --it;\n    }\n}\n\ntemplate class Iterator, TICK_REQUIRES(is_incrementable Iterator ()) \nvoid advance(Iterator  it, int n)\n{\n    while (n--) ++it;\n}  However, this leads to ambiguities when we try to use it with iterators to vectors. That is because those iterators are valid for all three overloads. So, tag dispatching allows us to pick the overload that is the most refined. First, we need to call  most_refined  which will retrieve the tags for each each trait. So then  advance  could be implemented like this:  template class Iterator \nvoid advance_impl(Iterator  it, int n, tick::tag is_advanceable )\n{\n    it += n;\n}\n\ntemplate class Iterator \nvoid advance_impl(Iterator  it, int n, tick::tag is_decrementable )\n{\n    if (n   0) while (n--) ++it;\n    else \n    {\n        n *= -1;\n        while (n--) --it;\n    }\n}\n\ntemplate class Iterator \nvoid advance_impl(Iterator  it, int n, tick::tag is_incrementable )\n{\n    while (n--) ++it;\n}\n\ntemplate class Iterator \nvoid advance(Iterator  it, int n)\n{\n    advance_impl(it, n, tick::most_refined is_advanceable Iterator ());\n}", 
            "title": "Tag dispatching"
        }, 
        {
            "location": "/tag/index.html#specialization", 
            "text": "Tag dispatching will still work with specialization. Say, for instance, someone implemented an iterator called  foo_iterator  that when the user called  +=  it would crash at runtime. So we would like to specialize  is_advanceable  to make it false, so the  +=  won't be called:  template \nstruct is_advanceable foo_iterator \n: std::false_type\n{};  So this will exclude the  is_advanceable  overload, but the  is_decrementable  and  is_incrementable  will still be called.", 
            "title": "Specialization"
        }, 
        {
            "location": "/requirements/index.html", 
            "text": "Requirements\n\n\nThis requires a C++11 compiler. There a no third-party dependencies. This has been tested on clang 3.4, gcc 4.6-4.9, and Visual Studio 2015.", 
            "title": "Requirements"
        }, 
        {
            "location": "/requirements/index.html#requirements", 
            "text": "This requires a C++11 compiler. There a no third-party dependencies. This has been tested on clang 3.4, gcc 4.6-4.9, and Visual Studio 2015.", 
            "title": "Requirements"
        }, 
        {
            "location": "/acknowledgments/index.html", 
            "text": "Acknowledgments\n\n\n\n\nEric Niebler for the idea of using a \nrequires\n member function to check concept traits.[http://ericniebler.com/2013/11/23/concept-checking-in-c11/]\n\n\nJamboree for the idea of using a template class to place expressions.[https://github.com/ericniebler/range-v3/issues/29#issuecomment-51016277]", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/acknowledgments/index.html#acknowledgments", 
            "text": "Eric Niebler for the idea of using a  requires  member function to check concept traits.[http://ericniebler.com/2013/11/23/concept-checking-in-c11/]  Jamboree for the idea of using a template class to place expressions.[https://github.com/ericniebler/range-v3/issues/29#issuecomment-51016277]", 
            "title": "Acknowledgments"
        }, 
        {
            "location": "/design/index.html", 
            "text": "Design Notes\n\n\nUsing template class\n\n\nTick uses a the \nvalid\n template class to place valid expressions, because it provides a more robust solution. Ideally, using tick we could define the traits like this:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n decltype(\n        x++,\n        ++x\n    );\n};\n\n\n\nHowever, if one of the expressions returns a type that overloads the comma operator in a strange way(rare but still possible), then the trait could fail(ie return false when it should be true). To fix it, we could add \nvoid\n casts like this:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n decltype(\n        (void)x++,\n        (void)++x\n    );\n};\n\n\n\nHowever, the \nvoid\n casts can be easy to forget. Another solution to the problem could be to pass it to a function:\n\n\ntemplate\nclass... Ts\n\nvoid valid_expr(T\n...);\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n decltype(valid_expr(\n        x++,\n        ++x\n    ));\n};\n\n\n\nHowever, if one of the expressions returns \nvoid\n, then this will fail as well(ie return false when it should be true). So this could be fixed in a similiar way as well:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n decltype(valid_expr(\n        (x++, 1),\n        (++x, 1)\n    ));\n};\n\n\n\nHowever, it can be easy to forget to put the \n1\n in there. So instead we use a \nvalid\n template class, like this:\n\n\nTICK_TRAIT(is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};\n\n\n\nThis requires placing each expression in a decltype, but if this was forgotten there would be a compile error pointing to the incorrect expression.\n\n\nTrait-based\n\n\nThe concept predicates in Tick are defined as regular type traits(ie they are integrel constants) instead of a \nconstexpr bool\n function. They are almost functionally the same in use. However, as a trait, it allows for better flexibility and expressiveness, through higher-order programming. This is what enables passing the traits to other functions which can be used to match return types to traits as well as other types.\n\n\nSpecializations\n\n\nAll the traits created can be specialized by the user. This is very important. Since the definition of traits relies on duck typing, there are times that even though it may quack like a duck it is not a duck. So with specialization the user can clarify the type's capabilities.", 
            "title": "Design Notes"
        }, 
        {
            "location": "/design/index.html#design-notes", 
            "text": "", 
            "title": "Design Notes"
        }, 
        {
            "location": "/design/index.html#using-template-class", 
            "text": "Tick uses a the  valid  template class to place valid expressions, because it provides a more robust solution. Ideally, using tick we could define the traits like this:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  decltype(\n        x++,\n        ++x\n    );\n};  However, if one of the expressions returns a type that overloads the comma operator in a strange way(rare but still possible), then the trait could fail(ie return false when it should be true). To fix it, we could add  void  casts like this:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  decltype(\n        (void)x++,\n        (void)++x\n    );\n};  However, the  void  casts can be easy to forget. Another solution to the problem could be to pass it to a function:  template class... Ts \nvoid valid_expr(T ...);\n\nTICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  decltype(valid_expr(\n        x++,\n        ++x\n    ));\n};  However, if one of the expressions returns  void , then this will fail as well(ie return false when it should be true). So this could be fixed in a similiar way as well:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  decltype(valid_expr(\n        (x++, 1),\n        (++x, 1)\n    ));\n};  However, it can be easy to forget to put the  1  in there. So instead we use a  valid  template class, like this:  TICK_TRAIT(is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};  This requires placing each expression in a decltype, but if this was forgotten there would be a compile error pointing to the incorrect expression.", 
            "title": "Using template class"
        }, 
        {
            "location": "/design/index.html#trait-based", 
            "text": "The concept predicates in Tick are defined as regular type traits(ie they are integrel constants) instead of a  constexpr bool  function. They are almost functionally the same in use. However, as a trait, it allows for better flexibility and expressiveness, through higher-order programming. This is what enables passing the traits to other functions which can be used to match return types to traits as well as other types.", 
            "title": "Trait-based"
        }, 
        {
            "location": "/design/index.html#specializations", 
            "text": "All the traits created can be specialized by the user. This is very important. Since the definition of traits relies on duck typing, there are times that even though it may quack like a duck it is not a duck. So with specialization the user can clarify the type's capabilities.", 
            "title": "Specializations"
        }, 
        {
            "location": "/zlang/index.html", 
            "text": "ZLang support\n\n\nZLang\n is supported for some of the macros. The macros are in the \ntick\n namespace. For example,\n\n\n$(trait is_incrementable)\n{\n    template\nclass T\n\n    auto require(T\n x) -\n valid\n\n        decltype(x++),\n        decltype(++x)\n    \n;\n};", 
            "title": "ZLang"
        }, 
        {
            "location": "/zlang/index.html#zlang-support", 
            "text": "ZLang  is supported for some of the macros. The macros are in the  tick  namespace. For example,  $(trait is_incrementable)\n{\n    template class T \n    auto require(T  x) -  valid \n        decltype(x++),\n        decltype(++x)\n     ;\n};", 
            "title": "ZLang support"
        }, 
        {
            "location": "/license/index.html", 
            "text": "Boost Software License - Version 1.0 - August 17th, 2003\n\n\nPermission is hereby granted, free of charge, to any person or organization\nobtaining a copy of the software and accompanying documentation covered by\nthis license (the \"Software\") to use, reproduce, display, distribute,\nexecute, and transmit the Software, and to prepare derivative works of the\nSoftware, and to permit third-parties to whom the Software is furnished to\ndo so, all subject to the following:\n\n\nThe copyright notices in the Software and this entire statement, including\nthe above license grant, this restriction and the following disclaimer,\nmust be included in all copies of the Software, in whole or in part, and\nall derivative works of the Software, unless such copies or derivative\nworks are solely in the form of machine-executable object code generated by\na source language processor.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\nSHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\nFOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}